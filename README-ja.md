# TEPA

[![test](https://github.com/arowM/tepa/actions/workflows/test.yaml/badge.svg)](https://github.com/arowM/tepa/actions/workflows/test.yaml)  
[Document](https://package.elm-lang.org/packages/arowM/tepa/latest/)

![logo](https://user-images.githubusercontent.com/1481749/115139779-de382400-a06e-11eb-80e7-22af97774bfa.jpg)

TEPA（ティーパ）

バグのない、よいユーザー体験を生むウェブアプリケーションのためのフレームワーク

## ウェブアプリケーションは誰のためのもの？

ウェブアプリケーションの主役はコンポーネントでしょうか？ それとも、オブジェクト？ 関数？ データ？
ウェブアプリケーションはそれを使うユーザーのためのものです。もちろん所有者はサービスの運営者ですが、ユーザーの気持ちを考えることなしに自社の都合を押し付けても、ユーザーは思い通りに動いてくれないでしょう。言うまでもなく、開発においてもユーザーの気持ちを考えることが最も大切です。

しかし現代のウェブアプリケーション開発はどうでしょうか？ 特にユーザーと直接かかわるはずのフロントエンドは、コンポーネントとか、データ状態とか、そういうユーザーの心とは関係ないものを中心に考えがちです。

ウェブブラウザーのDOM APIだって、DOM要素という開発者側の都合に縛られたものが主役です。

```js
window.addEventListener("load", () => {
  document.getElementById("submitButton").addEventListener("click", (event) => {
    // なんかコード
  });
});
```

上記の例では、「送信ボタン」というDOM要素が主体となっています。そのため、「ユーザーがどんな状況下でどんな過去を経てこのボタンを操作したのか」というアプリケーションにおいて当たり前の情報を手に入れるのも簡単ではありません。いくつものフラグや変数を用意して更新し、それらを全部じっくり解析して、「ペロッ。この状況から判断すると、これはもしかしたら他殺の可能性がありますね」なんていう探偵ごっこを毎回繰り返さなくてはなりません。

## ステートレス。それでいてコンテクストフル

アプリケーションが複雑化するにつれ、「ステートレス」の重要性が高まります。ステート、つまり現在時刻のようにアプリケーションを取り巻くさまざまな状態をうまく切り離してバグを減らそうという考えです。

さて、世の中にはUXという言葉があります。現代人の95%以上はきっと「UIっていうよりUI/UXって言ったほうがかっこいい」くらいの認識でしかない言葉ですが、これは「ユーザー体験」を意味する言葉です。「体験」ですから、当然これまでのユーザーの経験の蓄積のうえに成り立つものです。
本来ならユーザーがどんな家庭で育ってきて、どんな地域コミュニティに触れ、学校でどんな教育を受けてきたかまで遡ることすら必要です。それなのに、昨今のアプリケーション開発では、アプリケーションを読み込んだあとどのようなコンテクスト（文脈）でユーザーが今操作しているかすら、簡単には解析できないのです。

TEPAはステートレスですが、コンテクストフルです。ユーザーの操作の流れに沿った記述でアプリケーションを開発できます。

```elm
tutorial =
    Tepa.sequence
        [ showWelcomeMessage
        , awaitUserReactionToWelcomMessage <| \response ->
            case response of
                PoliteUserReaction ->
                    priseUser
                EvilUserReaction ->
                    punishUser
        ]
```

## 例外のないプログラミング

例外は、人類の発展を阻害する発明です。確かに想定外のことは考えたくありません。後回しにしたいものです。その気持ちは痛いほど分かります。でもそうやって後になって困るのもあなた自身です。
考えてみてください。飛行機をつくるなら、ネジの1つ1つにいたるまで慎重に検品し、想定外の不具合があればその場で取り替えませんか？ 全部組み立てたあとで飛行機が落ちたとしても、もう何が原因だったのかなんてわかりません。コンテクストが抜け落ちているのです。例外処理とは、便利ですがそういう危うさを持った技術です。

例外は静的型も台無しにします。TypeScriptを使ってJavaScriptにせっかく静的な型を導入しても、 `unknown` なんていう得体のしれない動的な型の値をあつかう必要があります。

TEPAでは、例外の存在しないElmという言語を採用しています。必ずその場で想定外の出来事に備えた対処をしないと、コンパイラーが許してくれません。最初は堅苦しく、鬱陶しく感じるかもしれません。でもいつの日か、その口うるさいコンパイラーに感謝する日がやってきます。

## シナリオが軽量なテストに

前述の通り、ウェブアプリケーション開発ではユーザーの心を考えることが欠かせません。そこでTEPAはユースケースシナリオ作成機能を用意しました。ユースケースシナリオとは、ユーザーがどのように考え、どのように操作し、それに対してシステムがどのように応答するかを具体的に想像して書き出したものです。このシナリオ作成機能を使えば、プログラムとしてシナリオを作成できます。そのシナリオはブラウザーでいい感じに整形して表示することもできますし、Markdownとして出力することもできます。

さらに驚くべきは、シナリオがそのまま軽量なテストになるということです。TEPAでアプリケーションを書き、TEPAでシナリオを書くと、そのアプリケーションの挙動をエミュレートしてシナリオ通りの動作をしているかテストできます。このテストは実際のウェブブラウザーを使っているわけではありません。そのため瞬時に完了します。たとえば5億年スリープする処理が入っていても、一瞬です。5億年後も地球が存続していることに賭けてコールドスリープする必要はありません。アプリケーション内でのバックエンドサーバーへのリクエストや、乱数の生成なども、シナリオに期待する挙動を書いておけばその結果をアプリケーションに渡してテストが進みます。モックサーバーなどは必要ありません。

もちろん、エミュレーターであることにはデメリットもあります。実際に画面をレンダリングしているわけではないので、ビジュアルリグレッションテストなどはできません。重要な部分はなんかPlaywrightとかそういうのを併用しましょう。

## はじめかた

人間さんはチュートリアルとかいうやつが大好きです。なんか言われた通りの手順に沿って手を動かしたらそれっぽいものができて分かった気にだけなれるやつです。 TEPAもそんなチュートリアルを現在作成しています。でもはすでに用意してあります。[spa-sampleディレクトリー](https://github.com/arowM/tepa/tree/main/spa-sample)の中身を参照してください。

[Elmの言語仕様](https://guide.elm-lang.jp/core_language.html)はすご〜く小さいのですぐに覚えられますし、型の助けを借りながらTEPAの[モジュールドキュメント](https://package.elm-lang.org/packages/arowM/tepa/latest/Tepa)を読めば `spa-sample` の構造が理解できるようになるはずです。

人間さんっていう生き物は、最新の技術ばかり追いかけて消耗するのが大好きですよね？ チュートリアルなんか待たずに早く手を出して他のプログラマーと差をつけましょう！
